;Originally From "Assembly Language Subroutines For the 6809"
; By Lance A Leventhal

; Available at https://archive.org/details/assembly-language-subroutines-for-the-6809_Leventhal

;Code available on https://github.com/jmatzen/leventhal-6809


; Modified 2022 by Don Barber to be C-style (nul terminated) instead of
; Pascale-style (leading length byte) string.

;
;	Title: 		Binary to-Decimal ASCII
;
;	Name:		BN2DEC
;
;	Purpose:	Converts a 16-bit signed binary number to ASCII data
;
;	Entry:		Register D = Value to convert 
;			Register X = Output buffer address
;
;	Exit:		The first byte of the buffer is the length,
;			followed by the characters
;
;	Registers Used: CC, D, X, Y
;
;	Time:		Approximately 1000 cycles
;
;	Size:		Program 99 bytes
;			Data up to 5 bytes on stack
;
;	SAVE ORIGINAL DATA IN BUFFER
;	TAKE ABSOLUTE VALUE IF DATA NEGATIVE
;
BN2DEC:
	STD	1,X			; SAVE DATA IN BUFFER
	BPL	CNVERT			; BRANCH IF DATA POSITIVE
	LDD	#0			; ELSE TAKE ABSOLUTE VALUE
	SUBD	1,X
;
; INITIALIZE STRING LENGTH TO ZERO
;
CNVERT:
	CLR	,X			; STRING LENGTH = 0
;
; DIVIDE BINARY DATA BY 10 BY
; SUBTRACTING POWERS OF TEN 
;
DIV10:
	LDY	#-1000			; START QUOTIENT AT -1000
;
; FIND NUMBER 0F THOUSANDS IN QUOTIENT
;
THOUSD:
	LEAY	1000,Y			; ADD 1000 TO QUOTIENT
	SUBD	#10000			; SUBTRACT 10000 FROM DIVIDEND
	BCC	THOUSD			; BRANCH IF DIFFERENCE STILL POSITIVE 
	ADDD	#10000			; ELSE ADD BACK LAST 10000
;
; FIND NUMBER OF HUNDREDS IN QUOTIENT
;
	LEAY	-100,Y			; START NUMBER OF HUNDREDS AT -1
HUNDD:
	LEAY	100,Y			; ADD 100 TO QUOTIENT
	SUBD	#1000			; SUBTRACT 1000 FROM DIVIDEND
	BCC	HUNDD			; BRANCH IF DIFFERENCE STILL POSITIVE
	ADDD	#1000			; ELSE ADD BACK LAST 1000
;
; FIND NUMBER OF TENS IN QUOTIENT
;
	LEAY	-10,Y			; STARTNUMBER OF TENS AT -1
TENSD:
	LEAY	10,Y			; ADD 10 TO QUOTIENT
	SUBD	#100			; SUBTRACT 100 FROM DIVIDEND
	BCC	TENSD			; BRANCH IF DIFFERENCE STILL POSITIVE
	ADDD	#100			; ELSE ADD BACK LAST 100
;
; FIND NUMBER OF ONES IN QUOTIENT
;
	LEAY	-1,Y			; START NUMBER OF ONES AT -1
ONESD:
	LEAY	1,Y			; ADD 1 TO QUOTIENT
	SUBD	#10			; SUBTRACT 10 FROM DIVIDEND
	BCC	ONESD			; BRANCH IF DIFFERENCE STILL POSITIVE
	ADDD	#10			; ELSE ADD BACK LAST 10
	STB	,-S			; SAVE REMAINDER IN STACK
					; THIS IS NEXT DIGIT, MOVING LEFT
					; LEAST SIGNIFICANT DIGIT GOES INTO STACK
					; FIRST
	INC	,X			; ADD 1 TO LENGTH BYTE

	TFR	Y,D			; MAKE QUOTIENT INTO NEN DIVIDEND 
	CMPD	#0			; CHECK IF DIVIDEND ZERO
	BNE	DIV10			; BRANCH IF NOT DIVIDE BY 10 AGAIN
;
; CHECK IF ORIGINAL BINARY DATA WNAS NEGATIVE
; IF SO, PUT ASCII AT FRONT OF BUFFER
;
	LDA	,X			; GET LENGTH BYTE (NOT INCLUDING SIGN)
	LDB	1,X			; GET HIGH BYTE OF DATA
	BPL	BUFLOAD			; BRANCH IF DATA POSITIVE
	LDB	#'-'			; OTHERWISE, GET ASCII MINUS SIGN
	STB	,X+			; STORE MINUS SIGN IN BUFFER
	INC	-2,X			; ADD 1 TO LENGTH BYTE FOR SIGN
;
; MOVE STRING OF DIGITS FROM STACK TO BUFFER 
; HOST SIGNIFICANT DIGIT IS AT TOP OF STACK
; CONVERT DIGITS TO ASCII BY ADDING ASCII 0
;
BUFLOAD:
	LDB	,S+			; GET NEXT DIGIT FROM STACK, MOVING RIGHT
	ADDB	#'0'			; CONVERT DIGIT TO ASCII
	STB	,X+			; SAVE DIGIT IN BUFFER
	DECA				; DECREMENT BYTE COUNTER
	BNE	BUFLOAD			; LOOP IF MORE BYTES LEFT
	CLR	,X
	RTS


